# Product Requirements Document (PRD) â€“ RoslynScribe Visualizer

## 1. Product Overview

The RoslynScribe Visualizer is a lightweight, client-side web tool designed to interactively visualize code execution flows analyzed by the RoslynScribe library. It operates as a single local HTML file with embedded JavaScript and CSS, requiring no server infrastructure or complex installation. The tool ingests JSON data generated by the ScribeAnalyzer and renders it as dynamic Mermaid.js flowcharts. It addresses the challenge of navigating large, complex execution trees by providing advanced filtering, "drill-down" expansion capabilities, and semantic search, all within a secure, offline-capable environment.

## 2. User Problem

Developers using static analysis tools often struggle to comprehend the massive amount of data generated. Raw JSON or text logs are difficult to trace, and static image generation produces diagrams that are either too high-level to be useful or too detailed to be readable ("spaghetti graphs").
Currently, users face these specific issues:
*   Inability to interactively explore code paths (expand/collapse) to focus on relevant logic.
*   Difficulty finding specific methods or tagged nodes (e.g., "Error" or "Warning") within a large graph.
*   Security and privacy concerns preventing the upload of proprietary code analysis data to online diagramming tools.
*   Dependency fatigue: avoiding tools that require running local web servers (Node/Python) or Docker containers just to view a chart.

## 3. Functional Requirements

### 3.1 Data Ingestion
*   The application must allow users to load a `ScribeResult` JSON file from their local file system using the browser's native file picker (`<input type="file">`).
*   The application must validate the loaded JSON schema (checking for `Nodes` and `Trees` properties) and display a user-friendly error message if invalid.
*   The application must allow loading an optional "Configuration JSON" file to restore previous view states (active filters, expanded nodes) and custom tag color mappings.

### 3.2 Graph Rendering
*   The application must render the execution flow using the Mermaid.js library with the `dagre` layout engine.
*   Nodes must support HTML content (`htmlLabels: true`) to embed interactive icons.
*   The graph must support subgraphs for the Project level (default) and 1st-Level Folders (optional toggle).
*   Recursive calls or backward flow edges must be styled with dashed lines.

### 3.3 Visibility & Interaction
*   **Default State:** Upon loading, only nodes with `Level = 1` must be visible.
*   **Drill-Down:** Nodes with hidden children must display a badge indicating the count of hidden nodes (e.g., `+3`). Clicking an "Expand" icon within the node must reveal these specific children and regenerate the graph.
*   **Node Details:** Clicking the body of a node must open a Side Panel displaying full metadata (Method Name, Class, File Path, Namespace).
*   **Focus:** Double-clicking a node must center the viewport on that node and expand its immediate children.
*   **Reset:** A "Reset View" button must clear all manual expansions and revert the graph to the default Level 1 state.

### 3.4 Search & Navigation
*   The application must provide a unified search bar for Text and Tags.
*   **Force Reveal:** If a search result corresponds to a hidden node, the application must automatically add that node (and its necessary ancestors) to the visible set, regenerate the graph, and center the view on the result.
*   **Navigation:** Users must be able to cycle through search results (Next/Previous), with the viewport panning to each match.

### 3.5 Styling & Theming
*   Nodes must be colored semantically: Blue (Standard), Green (Comment), and dynamic pastel colors for user-defined tags (based on hash of tag name).
*   Specific tags (e.g., "Warning", "Error") must be mapped to distinct visual styles (Yellow/Red borders or backgrounds).
*   The UI must support a "Loading..." overlay to indicate activity during heavy graph recalculations.

### 3.6 Persistence
*   Users must be able to save their current session as a JSON configuration file.
*   Saved state must include: Relative context (Active Tree ID), List of Expanded Node IDs, and Active Search Terms. It must NOT include absolute file paths.

## 4. Product Boundaries

*   **Scope:** The product is a visualization layer only. It does not perform the static analysis itself (that is done by the RoslynScribe backend).
*   **Platform:** The tool runs in modern web browsers (Chrome, Edge, Firefox, Safari). Legacy browsers (IE11) are out of scope.
*   **Delivery:** Single HTML file + compiled JS file + CSS file. No backend server, database, or cloud dependencies.
*   **Performance:** Optimized for medium-complexity graphs (100-300 visible nodes). Extremely large datasets (>1000 visible nodes) may experience UI lag, which is acceptable if managed via the loading overlay.
*   **Editability:** The tool allows filtering and hiding nodes but does not allow editing the underlying source code or analysis data.

## 5. User Stories

### US-001: Load Analysis Data
*   **Title:** Load ScribeResult JSON
*   **Description:** As a developer, I want to load my generated analysis file so that I can start visualizing the code flow.
*   **Acceptance Criteria:**
    *   User sees a prominent "Load Data" button.
    *   Selecting a valid `.json` file renders the initial graph.
    *   Selecting an invalid file shows an alert: "Invalid File Format. Please load a valid ScribeResult JSON."
    *   The browser does not attempt to upload the file to any server.

### US-002: View High-Level Flow
*   **Title:** Initial Level 1 Visualization
*   **Description:** As a user, I want to see only the high-level logic (Level 1) immediately after loading, so that I am not overwhelmed by details.
*   **Acceptance Criteria:**
    *   The graph renders only nodes where `Level <= 1`.
    *   Nodes with hidden children display a badge (e.g., `+N`).
    *   The graph fits within the viewport or starts at the root node.

### US-003: Expand Execution Path
*   **Title:** Drill-down into Details
*   **Description:** As a user, I want to click an icon on a specific node to reveal its hidden steps, so I can investigate a specific logic branch.
*   **Acceptance Criteria:**
    *   Each node with children has a clickable "Expand" icon.
    *   Clicking the icon adds the children to the graph.
    *   The graph layout updates to accommodate new nodes.
    *   The badge count on the parent node disappears or updates.

### US-004: View Node Metadata
*   **Title:** Inspect Node Details
*   **Description:** As a user, I want to see technical details about a step without cluttering the diagram, so I can understand the context (Class, Method).
*   **Acceptance Criteria:**
    *   Clicking a node (non-icon area) opens a Side Panel.
    *   The Side Panel displays: Method Name, Class Name, Namespace, File Path, and Line Number.
    *   The Side Panel displays any comments associated with the node.

### US-005: Search for Logic
*   **Title:** Text and Tag Search
*   **Description:** As a user, I want to find a node by its text or tag (e.g., "Validation" or "Error"), even if it is currently hidden.
*   **Acceptance Criteria:**
    *   Typing in the search bar highlights matching visible nodes.
    *   If a match is hidden, the system automatically expands its parent path to reveal it.
    *   The viewport centers on the first match.
    *   "Next" and "Previous" buttons navigate between multiple matches.

### US-006: Save Analysis State
*   **Title:** Export View Configuration
*   **Description:** As a user, I want to save my current view (expanded nodes, active filters) to a file, so I can share my findings with a colleague.
*   **Acceptance Criteria:**
    *   User clicks "Save Config".
    *   Browser downloads a `.json` file.
    *   The file contains the IDs of all currently visible nodes and the active search term.
    *   The file does not contain absolute paths to the data source.

### US-007: Restore Analysis State
*   **Title:** Load View Configuration
*   **Description:** As a user, I want to load a configuration file alongside the data, so I can resume my analysis exactly where I left off.
*   **Acceptance Criteria:**
    *   User loads Data JSON, then Config JSON.
    *   The graph updates to match the saved state (specific nodes expanded).
    *   If the Config does not match the Data (IDs missing), the system handles it gracefully (ignores missing IDs).

### US-008: Reset Visualization
*   **Title:** Reset to Default
*   **Description:** As a user, I want to quickly return to the initial state after exploring deep paths, so I can start a new investigation.
*   **Acceptance Criteria:**
    *   User clicks "Reset View".
    *   All manual expansions are cleared.
    *   The graph reverts to showing only Level 1 nodes.
    *   Search terms are cleared.
    *   Zoom and Pan are reset to default.

### US-009: Offline Access
*   **Title:** Offline Capability
*   **Description:** As a user, I want the tool to look and work correctly without an internet connection.
*   **Acceptance Criteria:**
    *   All icons render correctly without internet (using embedded SVG).
    *   Mermaid.js library is loaded from a local file (or bundled), not a CDN. (Note: For this specific simplified implementation, CDN usage was discussed as acceptable for libraries, but icons must be embedded. If strict offline for libraries is required, user must download them. *Correction based on Decisions*: The decision was "Local HTML file", implied CDN for libraries is usually acceptable for "local file" tools unless strictly "air-gapped". However, decision 6 said "Offline capability is strictly required... embed SVG". This implies full offline. We will assume libraries are provided in the folder or a specific 'strict' requirement exists. For this PRD, we assume the JS file provided is the app logic, and dependencies might need to be local too if strictly offline. The decision text emphasized *Icons* being embedded to avoid font requests.)

## 6. Success Metrics

*   **Load Time:** The application loads and is ready for interaction within 2 seconds of opening the HTML file.
*   **Rendering Performance:** Graph regeneration for a tree with 100 nodes completes in under 1.5 seconds on a standard developer laptop.
*   **Search Latency:** Search results are highlighted and focused within 500ms of input execution.
*   **Offline Functionality:** 100% of UI elements (icons, badges, layout) render correctly when the computer is disconnected from the network.
*   **User Error Rate:** Less than 5% of file load attempts result in an "Invalid Format" error (implying the error message and schema validation are clear).

